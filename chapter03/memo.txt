require
 노드의 모듈 시스템
 불러오기

-------- import VS require ----------

import React, {Component} from 'react';

class NumberBaseball extends Component{
    ...
}

//여러개 export 가능
export const hello = 'hello'; //불러올때 : import {hello}
export const bye = 'bye'; // import {bye}

//한개만 export 가능
export default NumberBaseball; //불러올때 : import NumberBaseball

------------------------------------------
//과거 문법
const React = require('react');
exports.hello = 'hello';
module.exports = NumberBaseball;

노드 모듈 시스템에서
module.exports = {hello: 'a'};
==
exports.hello = 'a';


=> 노드는 require 로 돌려주고 react는 import로 호환이 가능

------------------------------------------

import를 사용하면 node에서 error가 발생함 근데 어떻게 사용하냐고?
 => 바벨이 inport를 require로 바꿔줌

 -----------------------------------------

react에서 반복적인 작업할 때 배열의 map함수를 이용해서 구현

map() 메서드는 배열 내의 모든 요소 각각에 대하여 주어진 함수를 호출한 결과를 모아 새로운 배열을 반환합니다.

ex) const array1 = [1, 4, 9, 16];

    // pass a function to map
    const map1 = array1.map(x => x * 2);

    console.log(map1);
    // expected output: Array [2, 8, 18, 32]

[1,2,3,4,5].map((v)=> {
    return <div>{v}</div>    
})

<div>1</div>
<div>2</div>
<div>3</div>
<div>4</div>
<div>5</div>

이렇게 반복적인 작업에서 유용하게 쓰임

------------------------------------------

2차원인 배열

[
    ["사과", "맛있다"],
    ["바나나", "금방죽는다"],
    ["포도", "시다"],
    ["귤", "달다"],
    ["가지", "말이 필요없다"],
].map((v) => {
             return (
              <li>
                <b>{v[0]}</b>는 {v[1]}
              </li>
            );
          })

------------------------------------------------

2차원 객체

[
    { fruit: "사과", taste: "맛있다" },
    { fruit: "바나나", taste: "금방 죽는다" },
    { fruit: "포도", taste: "시다" },
    { fruit: "귤", taste: "달다" },
    { fruit: "가지", taste: "말이 필요없다" },
].map((v) => {
            return (
              <li>
                <b>{v.fruit}</b>는 {v.taste}
              </li>
            );
          })

-------------------------------------------------

map을 쓸때는 key를 적어줘야함
 리액트가 key를 보고 같은 컴포넌트인지 아닌지 판단함
 성능최적화, key를 기준으로 엘리먼트 추가, 수정, 삭제를 판단함

 [
    { fruit: "사과", taste: "맛있다" },
    { fruit: "바나나", taste: "금방 죽는다" },
    { fruit: "포도", taste: "시다" },
    { fruit: "귤", taste: "달다" },
    { fruit: "가지", taste: "말이 필요없다" },
    { fruit: "가지", taste: "말이 필요없냐?" },
].map((v) => {
            return (
              <li key={v.fruit + v.taste}>             <=== 이 부분 key 추가
                <b>{v.fruit}</b>는 {v.taste}
              </li>
            );
          })

-----------------------------------------------------------------

[
    { fruit: "사과", taste: "맛있다" },
    { fruit: "바나나", taste: "금방 죽는다" },
    { fruit: "포도", taste: "시다" },
    { fruit: "귤", taste: "달다" },
    { fruit: "가지", taste: "말이 필요없다" },
    { fruit: "가지", taste: "말이 필요없냐?" },
].map((v, i) => {
        return (
              <li key={i}>   <=== key 부분에 index값을 넣어주면 안됨, 성능최적화시 문제
                {i}. <b>{v.fruit}</b>는 {v.taste}
              </li>
            );
          })

but => 요소가 추가만 되는 배열인 경우 i를 키로 해도 되긴 함.

--------------------------------------------------------------

react는 array.push는 안됨

arr.push()를 하면 기존의 배열에 추가해주는 개념이기에 push하기 전과 후의 arr은 똑같은 놈

그렇게 때문에 react는 arr의 변화를 감지하지 못해 render해주지 못함.

이런 문제를 해결하기 위해 arr2 = [...arr, 2] 로 참조가 달라지게 해서 react가 알아차릴수 있게함

arr1.push(1);
arr2 = [...arr1, 2]; //arr2 = [1,2]

=> onSubmit에서 [...arr,num]구문을 통해 배열을 업데이트 해줌으로써 render함수가 다시 실행
   그래서 바로 화면에 추가적으로 표현할 수 있는것

* state, props 가 바뀌면 render가 다시 실행됨